{
  "id": "oop_fundamentals",
  "title": "OOP Fundamentals",
  "description": "Classes, inheritance, properties, and readable reprs.",
  "workshops": [
    {
      "id": "oop_01",
      "title": "Vehicle → Truck (inheritance + property)",
      "timeLimitMinutes": 10,
      "prompt": "Create class Vehicle(vin) with read-only property vin. Subclass Truck(Vehicle) with capacity (int). __repr__ should return 'Truck(VIN, capacity=...)'.",
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional OOP",
          "description": "Use standard class inheritance with @property decorator",
          "starterCode": "class Vehicle:\n    def __init__(self, vin):\n        pass\n\nclass Truck(Vehicle):\n    def __init__(self, vin, capacity):\n        pass\n    \n    def __repr__(self):\n        pass\n",
          "hints": [
            "Hint 1: Use @property for vin (no setter).",
            "Hint 2: In Truck.__init__, call super().__init__(vin).",
            "Hint 3: __repr__ returns a developer-friendly string."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  try:\n    V=ns['Vehicle']; T=ns['Truck']\n  except KeyError:\n    return {'score':0,'max_score':max_score,'feedback':'Classes missing'}\n  t=T('VIN1',1000)\n  if getattr(t,'vin',None)!='VIN1': return {'score':60,'max_score':max_score,'feedback':'vin property incorrect'}\n  if 'Truck(VIN1' not in repr(t): return {'score':80,'max_score':max_score,'feedback':'__repr__ format expected to include VIN and capacity'}\n  return {'score':100,'max_score':max_score,'feedback':'Good OOP work!'}\n"
        },
        {
          "id": "aop_audit",
          "title": "AOP: Audit Logging",
          "description": "Use Aspect-Oriented Programming with a decorator to log method calls for debugging and auditing",
          "starterCode": "from functools import wraps\n\ndef audit(fn):\n    @wraps(fn)\n    def wrapper(self, *args, **kwargs):\n        # TODO: print audit log before calling method\n        result = fn(self, *args, **kwargs)\n        # TODO: print audit log after method completes\n        return result\n    return wrapper\n\nclass Vehicle:\n    def __init__(self, vin):\n        self._vin = vin\n    \n    @audit\n    @property\n    def vin(self):\n        return self._vin\n\nclass Truck(Vehicle):\n    def __init__(self, vin, capacity):\n        # TODO: call super().__init__(vin) and store capacity\n        pass\n    \n    def __repr__(self):\n        # TODO: return formatted string\n        pass\n",
          "hints": [
            "Hint 1: In audit decorator, print f'[AUDIT] {self.__class__.__name__}.{fn.__name__} called'",
            "Hint 2: After fn() returns, print f'[AUDIT] {self.__class__.__name__}.{fn.__name__} completed'",
            "Hint 3: In Truck.__init__, call super().__init__(vin) and set self.capacity = capacity."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  try:\n    V=ns['Vehicle']; T=ns['Truck']\n  except KeyError:\n    return {'score':0,'max_score':max_score,'feedback':'Classes missing'}\n  # Capture print output\n  import io, sys\n  old_stdout = sys.stdout\n  sys.stdout = buffer = io.StringIO()\n  t=T('VIN1',1000)\n  vin_val = t.vin\n  output = buffer.getvalue()\n  sys.stdout = old_stdout\n  # Test basic functionality\n  if vin_val!='VIN1': return {'score':60,'max_score':max_score,'feedback':'vin property incorrect'}\n  if 'Truck(VIN1' not in repr(t): return {'score':70,'max_score':max_score,'feedback':'__repr__ format expected to include VIN and capacity'}\n  # Check if audit aspect works\n  if '[AUDIT]' not in output or 'vin' not in output:\n    return {'score':80,'max_score':max_score,'feedback':'Audit decorator should print [AUDIT] messages when vin is accessed'}\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if '@audit' not in source or 'wraps' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the @audit decorator pattern!'}\n  return {'score':100,'max_score':max_score,'feedback':'Excellent! AOP audit logging tracks object interactions.'}\n"
        }
      ]
    },
    {
      "id": "oop_02",
      "title": "classmethod vs staticmethod",
      "timeLimitMinutes": 8,
      "prompt": "Implement class Counter with: (a) class attribute total=0; (b) classmethod from_list(lst) that returns sum(lst); (c) staticmethod is_positive(x) -> bool.",
      "visualizations": [
        {
          "id": "counter_cli_dashboard",
          "type": "cli",
          "enabled": false,
          "config": {
            "template": "╔═══════════════════════════════════════╗\n║   🧮  Counter Class Visualization    ║\n╠═══════════════════════════════════════╣\n║  Class Defined: {class_name}          ║\n║  Methods Found: {methods}             ║\n╚═══════════════════════════════════════╝",
            "placeholders": {
              "class_name": "execution.classes.Counter.name",
              "methods": "execution.classes.Counter.methods"
            }
          }
        },
        {
          "id": "counter_web_dashboard",
          "type": "web",
          "enabled": true,
          "config": {
            "layout": "split-horizontal",
            "panels": [
              {
                "id": "code_panel",
                "type": "code",
                "title": "Your Solution"
              },
              {
                "id": "results_panel",
                "type": "results",
                "title": "Execution Results",
                "sections": [
                  {
                    "title": "Classes Defined",
                    "type": "list",
                    "data": "execution.classes"
                  },
                  {
                    "title": "Class Methods",
                    "type": "key-value",
                    "data": "execution.classes.Counter"
                  }
                ]
              }
            ]
          }
        }
      ],
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional Class Methods",
          "description": "Use standard @classmethod and @staticmethod decorators",
          "starterCode": "class Counter:\n    total = 0\n    @classmethod\n    def from_list(cls, lst):\n        # TODO\n        pass\n    @staticmethod\n    def is_positive(x):\n        # TODO\n        pass\n",
          "hints": [
            "Hint 1: classmethod receives cls.",
            "Hint 2: staticmethod has no cls/self.",
            "Hint 3: You can update Counter.total inside from_list."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  C=ns.get('Counter')\n  if C is None: return {'score':0,'max_score':max_score,'feedback':'Class missing'}\n  s=C.from_list([1,2,3])\n  if s!=6: return {'score':60,'max_score':max_score,'feedback':'from_list must sum values'}\n  if not C.is_positive(5) or C.is_positive(-1): return {'score':80,'max_score':max_score,'feedback':'is_positive incorrect'}\n  return {'score':100,'max_score':max_score,'feedback':'Solid!'}\n"
        },
        {
          "id": "aop_caching",
          "title": "AOP: Memoization Cache",
          "description": "Use Aspect-Oriented Programming with a decorator to cache expensive function results",
          "starterCode": "from functools import wraps\n\ndef memoize(fn):\n    cache = {}\n    @wraps(fn)\n    def wrapper(*args):\n        # TODO: check if args in cache, return cached value\n        # Otherwise, call fn(*args), store in cache, and return\n        pass\n    return wrapper\n\nclass Counter:\n    total = 0\n    \n    @classmethod\n    @memoize\n    def from_list(cls, lst):\n        # TODO: return sum(lst)\n        # Note: lst must be tuple for caching (lists aren't hashable)\n        pass\n    \n    @staticmethod\n    def is_positive(x):\n        # TODO: return x > 0\n        pass\n",
          "hints": [
            "Hint 1: In memoize, check 'if args in cache: return cache[args]'",
            "Hint 2: Otherwise, compute 'result = fn(*args)', then 'cache[args] = result' and return result.",
            "Hint 3: from_list should return sum(lst), is_positive should return x > 0."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  C=ns.get('Counter')\n  if C is None: return {'score':0,'max_score':max_score,'feedback':'Class missing'}\n  # Test basic functionality\n  s=C.from_list((1,2,3))  # Use tuple for hashability\n  if s!=6: return {'score':60,'max_score':max_score,'feedback':'from_list must sum values'}\n  if not C.is_positive(5) or C.is_positive(-1): return {'score':70,'max_score':max_score,'feedback':'is_positive incorrect'}\n  # Test caching by calling twice and checking it returns same result\n  s2=C.from_list((1,2,3))\n  if s2!=6: return {'score':80,'max_score':max_score,'feedback':'Cached result should still be 6'}\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if 'memoize' not in source or 'cache' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the memoize decorator pattern!'}\n  return {'score':100,'max_score':max_score,'feedback':'Perfect! AOP caching optimizes performance elegantly.'}\n"
        }
      ]
    }
  ]
}

