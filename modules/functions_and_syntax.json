{
  "id": "functions_and_syntax",
  "title": "Functions & Syntax",
  "description": "Master function signatures, defaults, *args/**kwargs, and returns.",
  "workshops": [
    {
      "id": "fx_01",
      "title": "Safe Divider (defaults + error guard)",
      "timeLimitMinutes": 7,
      "prompt": "Implement safe_divide(a, b, default=0) that returns a/b. If b==0, return default.",
      "visualizations": [
        {
          "id": "safe_divide_web_dashboard",
          "type": "web",
          "enabled": true,
          "config": {
            "layout": "split-horizontal",
            "panels": [
              {
                "id": "code_panel",
                "type": "code",
                "title": "Your Solution"
              },
              {
                "id": "results_panel",
                "type": "results",
                "title": "Execution Results",
                "sections": [
                  {
                    "title": "Functions Defined",
                    "type": "list",
                    "data": "execution.functions"
                  },
                  {
                    "title": "Variables",
                    "type": "key-value",
                    "data": "execution.variables"
                  }
                ]
              }
            ]
          }
        }
      ],
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional If-Check",
          "description": "Use simple if-statement to check for zero before dividing",
          "starterCode": "def safe_divide(a, b, default=0):\n    # TODO: handle division by zero via default\n    pass\n",
          "hints": [
            "Hint 1: Use 'if b == 0:' early-return the default.",
            "Hint 2: No exceptions needed for this one.",
            "Hint 3: Make 'default' a keyword with a sensible default."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'safe_divide' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['safe_divide']\n  try:\n    if f(6,3)!=2: return {'score':40,'max_score':max_score,'feedback':'6/3 should be 2'}\n    if f(1,0)!=0: return {'score':60,'max_score':max_score,'feedback':'Default when b==0 should be used'}\n    if f(1,0,default=99)!=99: return {'score':80,'max_score':max_score,'feedback':'Keyword default not applied'}\n    return {'score':100,'max_score':max_score,'feedback':'Great!'}\n  except Exception as e:\n    return {'score':0,'max_score':max_score,'feedback':str(e)}\n"
        },
        {
          "id": "aop_timing",
          "title": "AOP: Performance Timing",
          "description": "Use Aspect-Oriented Programming with a decorator to measure execution time without cluttering code",
          "starterCode": "from functools import wraps\nimport time\n\ndef timer(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        # TODO: record start time\n        result = fn(*args, **kwargs)\n        # TODO: calculate elapsed time and print\n        return result\n    return wrapper\n\n@timer\ndef safe_divide(a, b, default=0):\n    # TODO: implement safe division logic\n    pass\n",
          "hints": [
            "Hint 1: Use time.time() to get current timestamp before and after calling fn().",
            "Hint 2: Print elapsed time like f'[TIMER] {fn.__name__} took {elapsed:.6f}s'",
            "Hint 3: The safe_divide logic is simple: check if b==0, return default, else return a/b."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'safe_divide' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['safe_divide']\n  try:\n    # Capture print output\n    import io, sys\n    old_stdout = sys.stdout\n    sys.stdout = buffer = io.StringIO()\n    # Test basic functionality\n    if f(6,3)!=2: return {'score':40,'max_score':max_score,'feedback':'6/3 should be 2'}\n    if f(1,0)!=0: return {'score':60,'max_score':max_score,'feedback':'Default when b==0 should be used'}\n    if f(1,0,default=99)!=99: return {'score':70,'max_score':max_score,'feedback':'Keyword default not applied'}\n    output = buffer.getvalue()\n    sys.stdout = old_stdout\n    # Check if timing aspect works\n    if '[TIMER]' not in output or 'took' not in output:\n      return {'score':80,'max_score':max_score,'feedback':'Timer decorator should print [TIMER] messages'}\n    # Check if decorator pattern was used\n    source = ns.get('__source__', '')\n    if '@' not in source or 'wraps' not in source:\n      return {'score':85,'max_score':max_score,'feedback':'Works, but use the decorator pattern with @wraps!'}\n    return {'score':100,'max_score':max_score,'feedback':'Excellent! AOP timing monitors performance cleanly.'}\n  except Exception as e:\n    return {'score':0,'max_score':max_score,'feedback':str(e)}\n"
        }
      ]
    },
    {
      "id": "fx_02",
      "title": "*args/**kwargs Echo",
      "timeLimitMinutes": 8,
      "prompt": "Implement echo_signature(*args, **kwargs) that returns a tuple: (list(args), sorted list of (key,value) pairs by key).",
      "visualizations": [
        {
          "id": "echo_signature_web_dashboard",
          "type": "web",
          "enabled": true,
          "config": {
            "layout": "split-horizontal",
            "panels": [
              {
                "id": "code_panel",
                "type": "code",
                "title": "Your Solution"
              },
              {
                "id": "results_panel",
                "type": "results",
                "title": "Execution Results",
                "sections": [
                  {
                    "title": "Functions Defined",
                    "type": "list",
                    "data": "execution.functions"
                  },
                  {
                    "title": "Variables",
                    "type": "key-value",
                    "data": "execution.variables"
                  }
                ]
              }
            ]
          }
        }
      ],
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional Implementation",
          "description": "Use direct list() and sorted() operations on args and kwargs",
          "starterCode": "def echo_signature(*args, **kwargs):\n    # TODO: return (list(args), sorted list of (key,value))\n    pass\n",
          "hints": [
            "Hint 1: list(args) gives a list of positional args.",
            "Hint 2: kwargs.items() can be sorted by key.",
            "Hint 3: return a tuple (.., ..)."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'echo_signature' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['echo_signature']\n  p,k=f(1,2,a=3,b=4)\n  if p!=[1,2]: return {'score':50,'max_score':max_score,'feedback':'Positional args wrong'}\n  if k!=[('a',3),('b',4)]: return {'score':80,'max_score':max_score,'feedback':'Keyword sorting wrong'}\n  return {'score':100,'max_score':max_score,'feedback':'Nice!'}\n"
        },
        {
          "id": "aop_type_checking",
          "title": "AOP: Type Validation",
          "description": "Use Aspect-Oriented Programming with a decorator to validate argument types at runtime",
          "starterCode": "from functools import wraps\n\ndef validate_types(*expected_types):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            # TODO: validate that all args match expected_types\n            # Raise TypeError if any arg doesn't match\n            return fn(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@validate_types(int, int)  # Expects all args to be integers\ndef echo_signature(*args, **kwargs):\n    # TODO: return (list(args), sorted list of (key,value))\n    pass\n",
          "hints": [
            "Hint 1: In the wrapper, use enumerate(args) to check each arg against expected_types.",
            "Hint 2: Check 'if i < len(expected_types) and not isinstance(arg, expected_types[i]): raise TypeError(...)'",
            "Hint 3: The echo_signature logic is: return (list(args), sorted(kwargs.items()))."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'echo_signature' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['echo_signature']\n  try:\n    # Test basic functionality\n    p,k=f(1,2,a=3,b=4)\n    if p!=[1,2]: return {'score':50,'max_score':max_score,'feedback':'Positional args wrong'}\n    if k!=[('a',3),('b',4)]: return {'score':60,'max_score':max_score,'feedback':'Keyword sorting wrong'}\n    # Test type validation aspect\n    try:\n      f('bad', 2, a=3)\n      return {'score':80,'max_score':max_score,'feedback':'Type validation should raise TypeError for non-int args'}\n    except TypeError:\n      pass  # Expected\n    # Check if decorator pattern was used\n    source = ns.get('__source__', '')\n    if '@' not in source or 'wraps' not in source:\n      return {'score':85,'max_score':max_score,'feedback':'Works, but use the decorator pattern with @wraps!'}\n    return {'score':100,'max_score':max_score,'feedback':'Perfect! AOP type checking adds runtime safety.'}\n  except Exception as e:\n    return {'score':0,'max_score':max_score,'feedback':str(e)}\n"
        }
      ]
    }
  ]
}

