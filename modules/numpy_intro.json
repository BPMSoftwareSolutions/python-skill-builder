{
  "id": "numpy_intro",
  "title": "NumPy Intro",
  "description": "Vector operations, elementwise arithmetic, shapes.",
  "workshops": [
    {
      "id": "np_01",
      "title": "Elementwise ops",
      "timeLimitMinutes": 8,
      "prompt": "Implement vec_add(a,b) using NumPy arrays to return elementwise sum as a Python list.",
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional NumPy",
          "description": "Use standard NumPy array operations",
          "starterCode": "def vec_add(a, b):\n    # TODO: import numpy and do elementwise add; return list\n    pass\n",
          "hints": [
            "Hint 1: import numpy as np inside function (AST guard limits globals).",
            "Hint 2: np.array(a) + np.array(b).",
            "Hint 3: Convert back with .tolist()."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('vec_add')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  out=f([1,2,3],[4,5,6])\n  if out!=[5,7,9]: return {'score':60,'max_score':max_score,'feedback':'Elementwise add wrong'}\n  return {'score':100,'max_score':max_score,'feedback':'Vectorized!'}\n"
        },
        {
          "id": "aop_shape_validation",
          "title": "AOP: Shape Validation",
          "description": "Use Aspect-Oriented Programming with a decorator to validate array shapes match before operations",
          "starterCode": "from functools import wraps\n\ndef validate_shapes(fn):\n    @wraps(fn)\n    def wrapper(a, b):\n        # TODO: validate that len(a) == len(b)\n        # Raise ValueError if shapes don't match\n        return fn(a, b)\n    return wrapper\n\n@validate_shapes\ndef vec_add(a, b):\n    # TODO: import numpy, add arrays, return list\n    pass\n",
          "hints": [
            "Hint 1: In decorator, check 'if len(a) != len(b): raise ValueError(\"Shape mismatch\")'",
            "Hint 2: In vec_add, import numpy as np, then return (np.array(a) + np.array(b)).tolist()",
            "Hint 3: The decorator handles validation; the function just does the math."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('vec_add')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  # Test basic functionality\n  out=f([1,2,3],[4,5,6])\n  if out!=[5,7,9]: return {'score':60,'max_score':max_score,'feedback':'Elementwise add wrong'}\n  # Test shape validation\n  try:\n    f([1,2], [3,4,5])\n    return {'score':80,'max_score':max_score,'feedback':'Should validate shapes match'}\n  except ValueError:\n    pass  # Expected\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if '@validate_shapes' not in source or 'wraps' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the @validate_shapes decorator!'}\n  return {'score':100,'max_score':max_score,'feedback':'Excellent! AOP shape validation prevents errors.'}\n"
        }
      ]
    },
    {
      "id": "np_02",
      "title": "Dot product",
      "timeLimitMinutes": 8,
      "prompt": "Implement dot(a,b) returning integer dot product using NumPy.",
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional NumPy",
          "description": "Use standard np.dot() function",
          "starterCode": "def dot(a, b):\n    # TODO: use np.dot\n    pass\n",
          "hints": [
            "Hint 1: np.dot(np.array(a), np.array(b)).",
            "Hint 2: Return int() for plain integer result."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('dot')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  if f([1,2,3],[4,5,6])!=32: return {'score':60,'max_score':max_score,'feedback':'Expected 32'}\n  return {'score':100,'max_score':max_score,'feedback':'Good dot!'}\n"
        },
        {
          "id": "aop_profiling",
          "title": "AOP: Performance Profiling",
          "description": "Use Aspect-Oriented Programming with a decorator to profile memory usage and execution time",
          "starterCode": "from functools import wraps\nimport time\n\ndef profile(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        # TODO: record start time and memory info\n        start = time.time()\n        result = fn(*args, **kwargs)\n        elapsed = time.time() - start\n        # TODO: print profiling info\n        return result\n    return wrapper\n\n@profile\ndef dot(a, b):\n    # TODO: use np.dot to compute dot product\n    pass\n",
          "hints": [
            "Hint 1: After computing result, print f'[PROFILE] {fn.__name__} took {elapsed:.6f}s'",
            "Hint 2: You can also print f'[PROFILE] Input sizes: {len(args[0])}, {len(args[1])}'",
            "Hint 3: In dot(), import numpy as np, return int(np.dot(np.array(a), np.array(b)))"
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('dot')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  # Capture print output\n  import io, sys\n  old_stdout = sys.stdout\n  sys.stdout = buffer = io.StringIO()\n  result = f([1,2,3],[4,5,6])\n  output = buffer.getvalue()\n  sys.stdout = old_stdout\n  # Test basic functionality\n  if result!=32: return {'score':60,'max_score':max_score,'feedback':'Expected 32'}\n  # Check if profiling aspect works\n  if '[PROFILE]' not in output or 'took' not in output:\n    return {'score':80,'max_score':max_score,'feedback':'Profiling decorator should print [PROFILE] messages'}\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if '@profile' not in source or 'wraps' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the @profile decorator!'}\n  return {'score':100,'max_score':max_score,'feedback':'Perfect! AOP profiling monitors performance.'}\n"
        }
      ]
    }
  ]
}

