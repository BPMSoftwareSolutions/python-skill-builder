{
  "id": "errors_and_debugging",
  "title": "Errors & Debugging",
  "description": "Use try/except/else/finally and custom exceptions to write robust code.",
  "workshops": [
    {
      "id": "err_01",
      "title": "Custom Exception",
      "timeLimitMinutes": 7,
      "prompt": "Define BadInput(Exception). Implement parse_int(s) that returns int(s) or raises BadInput on failure.",
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional Try-Except",
          "description": "Use standard try-except block to catch and re-raise exceptions",
          "starterCode": "class BadInput(Exception):\n    pass\n\ndef parse_int(s):\n    # TODO: convert to int, else raise BadInput\n    pass\n",
          "hints": [
            "Hint 1: Wrap int(s) in try/except.",
            "Hint 2: On ValueError, raise BadInput instead."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'parse_int' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['parse_int']; Bad=ns.get('BadInput')\n  if f('10')!=10: return {'score':60,'max_score':max_score,'feedback':'Should parse valid int'}\n  try:\n    f('x')\n  except Bad:\n    return {'score':100,'max_score':max_score,'feedback':'Correct exception raised'}\n  except Exception:\n    return {'score':80,'max_score':max_score,'feedback':'Wrong exception type'}\n  return {'score':40,'max_score':max_score,'feedback':'Did not raise on invalid input'}\n"
        },
        {
          "id": "aop_retry",
          "title": "AOP: Retry with Backoff",
          "description": "Use Aspect-Oriented Programming with a decorator to automatically retry failed operations with exponential backoff",
          "starterCode": "from functools import wraps\nimport time\n\ndef retry(max_attempts=3, delay=0.1):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            # TODO: loop through attempts\n            # On last attempt, re-raise exception\n            # Otherwise, sleep with exponential backoff\n            pass\n        return wrapper\n    return decorator\n\nclass BadInput(Exception):\n    pass\n\n@retry(max_attempts=3)\ndef parse_int(s):\n    # TODO: convert to int or raise BadInput\n    pass\n",
          "hints": [
            "Hint 1: Use 'for attempt in range(max_attempts):' to loop through attempts.",
            "Hint 2: Wrap fn(*args, **kwargs) in try-except. If attempt == max_attempts - 1, re-raise.",
            "Hint 3: Otherwise, sleep with time.sleep(delay * (2 ** attempt)) for exponential backoff."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  if 'parse_int' not in ns: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  f=ns['parse_int']; Bad=ns.get('BadInput')\n  # Test basic functionality\n  if f('10')!=10: return {'score':60,'max_score':max_score,'feedback':'Should parse valid int'}\n  # Test that it still raises on invalid input\n  try:\n    f('x')\n  except (Bad, ValueError):\n    pass  # Expected\n  except Exception:\n    return {'score':70,'max_score':max_score,'feedback':'Wrong exception type'}\n  else:\n    return {'score':40,'max_score':max_score,'feedback':'Did not raise on invalid input'}\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if '@retry' not in source or 'wraps' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the @retry decorator pattern!'}\n  return {'score':100,'max_score':max_score,'feedback':'Excellent! AOP retry adds resilience automatically.'}\n"
        }
      ]
    },
    {
      "id": "err_02",
      "title": "try/except/else/finally",
      "timeLimitMinutes": 10,
      "prompt": "Implement open_and_count(path) that opens a text file, returns number of lines. On FileNotFoundError return -1. Always set a variable 'closed' to True in finally (return both count, closed).",
      "approaches": [
        {
          "id": "traditional",
          "title": "Traditional Try-Except-Finally",
          "description": "Use standard try-except-finally block for error handling and cleanup",
          "starterCode": "def open_and_count(path):\n    closed=False\n    # TODO: try to open file, count lines; handle not found; ensure closed=True in finally\n    pass\n",
          "hints": [
            "Hint 1: Use try/except FileNotFoundError.",
            "Hint 2: Use finally to toggle closed=True.",
            "Hint 3: Return (count, closed)."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('open_and_count')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  # create temp file\n  import os, tempfile\n  fd, p = tempfile.mkstemp(text=True)\n  os.write(fd, b'a\\nb\\nc')\n  os.close(fd)\n  c, closed = f(p)\n  if c<2: return {'score':60,'max_score':max_score,'feedback':'Count seems wrong'}\n  if closed is not True: return {'score':80,'max_score':max_score,'feedback':'Must set closed=True in finally'}\n  c2, closed2 = f('no_such_file.txt')\n  if c2!=-1: return {'score':90,'max_score':max_score,'feedback':'Return -1 when missing'}\n  return {'score':100,'max_score':max_score,'feedback':'Great'}\n"
        },
        {
          "id": "aop_error_handling",
          "title": "AOP: Centralized Error Handler",
          "description": "Use Aspect-Oriented Programming with a decorator to handle errors consistently across functions",
          "starterCode": "from functools import wraps\n\ndef handle_errors(default_value=-1):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            # TODO: wrap fn() call in try-except\n            # Catch FileNotFoundError and return (default_value, True)\n            # On success, return (result, True)\n            pass\n        return wrapper\n    return decorator\n\n@handle_errors(default_value=-1)\ndef open_and_count(path):\n    # TODO: open file, count lines, return count\n    # No need for try-except here - decorator handles it!\n    pass\n",
          "hints": [
            "Hint 1: In wrapper, use try-except FileNotFoundError around fn(*args, **kwargs).",
            "Hint 2: On FileNotFoundError, return (default_value, True).",
            "Hint 3: In open_and_count, just open file with 'with open(path) as f:', count lines with len(f.readlines()), return count."
          ],
          "tests": "def grade(ns):\n  max_score=100\n  f=ns.get('open_and_count')\n  if not f: return {'score':0,'max_score':max_score,'feedback':'Function missing'}\n  # create temp file\n  import os, tempfile\n  fd, p = tempfile.mkstemp(text=True)\n  os.write(fd, b'a\\nb\\nc')\n  os.close(fd)\n  result = f(p)\n  if not isinstance(result, tuple) or len(result) != 2:\n    return {'score':50,'max_score':max_score,'feedback':'Should return tuple (count, closed)'}\n  c, closed = result\n  if c<2: return {'score':60,'max_score':max_score,'feedback':'Count seems wrong'}\n  if closed is not True: return {'score':70,'max_score':max_score,'feedback':'Must return closed=True'}\n  c2, closed2 = f('no_such_file.txt')\n  if c2!=-1: return {'score':80,'max_score':max_score,'feedback':'Return -1 when missing'}\n  # Check if decorator pattern was used\n  source = ns.get('__source__', '')\n  if '@handle_errors' not in source or 'wraps' not in source:\n    return {'score':85,'max_score':max_score,'feedback':'Works, but use the @handle_errors decorator pattern!'}\n  return {'score':100,'max_score':max_score,'feedback':'Perfect! AOP error handling centralizes exception logic.'}\n"
        }
      ]
    }
  ]
}

